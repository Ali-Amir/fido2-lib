const parser = require("../lib/parser");
var assert = require("chai").assert;
const h = require("fido2-helpers");

describe("parser", function() {
    it("is object", function() {
        assert.isObject(parser);
    });

    describe("parseExpectations", function() {
        it("returns Map on good expectations", function() {
            var exp = {
                origin: "https://webauthn.bin.coffee",
                challenge: "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg"
            };
            var ret = parser.parseExpectations(exp);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 3);
            assert.strictEqual(ret.get("origin"), exp.origin);
            assert.strictEqual(ret.get("challenge"), exp.challenge);
        });

        it("doesn't add extra items to Map", function() {
            var exp = {
                origin: "https://webauthn.bin.coffee",
                challenge: "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg",
                foo: "bar",
                beer: true
            };
            var ret = parser.parseExpectations(exp);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 3);
            assert.strictEqual(ret.get("origin"), exp.origin);
            assert.strictEqual(ret.get("challenge"), exp.challenge);
        });

        it("throws on invalid origin", function() {
            var exp = {
                origin: "asdf",
                challenge: "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg"
            };
            assert.throws(() => {
                parser.parseExpectations(exp);
            }, TypeError, "Invalid URL: asdf");
        });

        it("throws on undefined origin", function() {
            var exp = {
                challenge: "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg"
            };
            assert.throws(() => {
                parser.parseExpectations(exp);
            }, TypeError, "expected 'origin' should be string, got undefined");
        });

        it("coerces Array challenge to base64url", function() {
            var exp = {
                origin: "https://webauthn.bin.coffee",
                challenge: [
                    0xe0, 0x14, 0xb5, 0x60, 0x92, 0x91, 0x09, 0xe0, 0x95, 0xa0, 0xb7, 0x5f, 0x1b, 0xf6, 0xfa, 0xe8,
                    0x1b, 0x92, 0x43, 0xe2, 0x36, 0x9f, 0x7e, 0x16, 0xb0, 0xb1, 0x6f, 0xcb, 0xad, 0x9f, 0xa4, 0x85,
                    0x45, 0x8e, 0xb9, 0xb7, 0xdb, 0xfb, 0x45, 0x45, 0x08, 0xb1, 0x5f, 0xd5, 0x3c, 0x10, 0x15, 0x53,
                    0xae, 0x24, 0xe4, 0xad, 0xe0, 0x29, 0xfb, 0x59, 0xc3, 0xbd, 0x86, 0xe8, 0x44, 0xaf, 0x56, 0x16
                ]
            };
            var base64UrlChallenge = "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg";
            var ret = parser.parseExpectations(exp);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 3);
            assert.strictEqual(ret.get("origin"), exp.origin);
            assert.strictEqual(ret.get("challenge"), base64UrlChallenge);
        });


        it("coerces Uint8Array challenge to base64url", function() {
            var exp = {
                origin: "https://webauthn.bin.coffee",
                challenge: Uint8Array.from([
                    0xe0, 0x14, 0xb5, 0x60, 0x92, 0x91, 0x09, 0xe0, 0x95, 0xa0, 0xb7, 0x5f, 0x1b, 0xf6, 0xfa, 0xe8,
                    0x1b, 0x92, 0x43, 0xe2, 0x36, 0x9f, 0x7e, 0x16, 0xb0, 0xb1, 0x6f, 0xcb, 0xad, 0x9f, 0xa4, 0x85,
                    0x45, 0x8e, 0xb9, 0xb7, 0xdb, 0xfb, 0x45, 0x45, 0x08, 0xb1, 0x5f, 0xd5, 0x3c, 0x10, 0x15, 0x53,
                    0xae, 0x24, 0xe4, 0xad, 0xe0, 0x29, 0xfb, 0x59, 0xc3, 0xbd, 0x86, 0xe8, 0x44, 0xaf, 0x56, 0x16
                ])
            };
            var base64UrlChallenge = "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg";
            var ret = parser.parseExpectations(exp);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 3);
            assert.strictEqual(ret.get("origin"), exp.origin);
            assert.strictEqual(ret.get("challenge"), base64UrlChallenge);
        });

        it("coerces ArrayBuffer challenge to base64url", function() {
            var exp = {
                origin: "https://webauthn.bin.coffee",
                challenge: Uint8Array.from([
                    0xe0, 0x14, 0xb5, 0x60, 0x92, 0x91, 0x09, 0xe0, 0x95, 0xa0, 0xb7, 0x5f, 0x1b, 0xf6, 0xfa, 0xe8,
                    0x1b, 0x92, 0x43, 0xe2, 0x36, 0x9f, 0x7e, 0x16, 0xb0, 0xb1, 0x6f, 0xcb, 0xad, 0x9f, 0xa4, 0x85,
                    0x45, 0x8e, 0xb9, 0xb7, 0xdb, 0xfb, 0x45, 0x45, 0x08, 0xb1, 0x5f, 0xd5, 0x3c, 0x10, 0x15, 0x53,
                    0xae, 0x24, 0xe4, 0xad, 0xe0, 0x29, 0xfb, 0x59, 0xc3, 0xbd, 0x86, 0xe8, 0x44, 0xaf, 0x56, 0x16
                ]).buffer
            };
            var base64UrlChallenge = "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg";
            var ret = parser.parseExpectations(exp);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 3);
            assert.strictEqual(ret.get("origin"), exp.origin);
            assert.strictEqual(ret.get("challenge"), base64UrlChallenge);
        });

        it("coerces Buffer challenge to base64url", function() {
            var exp = {
                origin: "https://webauthn.bin.coffee",
                challenge: Buffer.from([
                    0xe0, 0x14, 0xb5, 0x60, 0x92, 0x91, 0x09, 0xe0, 0x95, 0xa0, 0xb7, 0x5f, 0x1b, 0xf6, 0xfa, 0xe8,
                    0x1b, 0x92, 0x43, 0xe2, 0x36, 0x9f, 0x7e, 0x16, 0xb0, 0xb1, 0x6f, 0xcb, 0xad, 0x9f, 0xa4, 0x85,
                    0x45, 0x8e, 0xb9, 0xb7, 0xdb, 0xfb, 0x45, 0x45, 0x08, 0xb1, 0x5f, 0xd5, 0x3c, 0x10, 0x15, 0x53,
                    0xae, 0x24, 0xe4, 0xad, 0xe0, 0x29, 0xfb, 0x59, 0xc3, 0xbd, 0x86, 0xe8, 0x44, 0xaf, 0x56, 0x16
                ])
            };
            var base64UrlChallenge = "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg";
            var ret = parser.parseExpectations(exp);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 3);
            assert.strictEqual(ret.get("origin"), exp.origin);
            assert.strictEqual(ret.get("challenge"), base64UrlChallenge);
        });

        it("coerces base64 challenge to base64url", function() {
            var exp = {
                origin: "https://webauthn.bin.coffee",
                challenge: "4BS1YJKRCeCVoLdfG/b66BuSQ+I2n34WsLFvy62fpIVFjrm32/tFRQixX9U8EBVTriTkreAp+1nDvYboRK9WFg"
            };
            var base64UrlChallenge = "4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg";
            var ret = parser.parseExpectations(exp);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 3);
            assert.strictEqual(ret.get("origin"), exp.origin);
            assert.strictEqual(ret.get("challenge"), base64UrlChallenge);
        });
    });

    describe("parseClientData", function() {
        it("correctly converts attestation JSON", function() {
            var ret = parser.parseClientData(h.lib.makeCredentialAttestationNoneResponse.response.clientDataJSON);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 5);
            assert.strictEqual(ret.get("challenge"), "33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w");
            // assert.deepEqual(ret.get("clientExtensions"), {});
            // assert.strictEqual(ret.get("hashAlgorithm"), "SHA-256");
            assert.strictEqual(ret.get("origin"), "https://localhost:8443");
            assert.strictEqual(ret.get("type"), "webauthn.create");
            assert.strictEqual(ret.get("tokenBinding", undefined));
            assert.instanceOf(ret.get("rawClientDataJson"), ArrayBuffer);
            // TODO: validate rawClientDataJson
        });

        it("correctly parses assertion JSON", function() {
            var ret = parser.parseClientData(h.lib.assertionResponse.response.clientDataJSON);
            console.log("clientData", ret);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 5);
            assert.strictEqual(ret.get("challenge"), "IwetcHKXUmttvH_5PK2cc2O5wDSUZ58GqAWFIVLIUKeoq8hokKoEe4pUgTr_4cpSVcbGkTqGxnEapDLTiGwUbg");
            // assert.deepEqual(ret.get("clientExtensions"), {});
            // assert.strictEqual(ret.get("hashAlgorithm"), "SHA-256");
            assert.strictEqual(ret.get("origin"), "https://localhost:8443");
            assert.strictEqual(ret.get("type"), "webauthn.get");
            assert.strictEqual(ret.get("tokenBinding", undefined));
            assert.instanceOf(ret.get("rawClientDataJson"), ArrayBuffer);
            // TODO: validate rawClientDataJson
        });

        it("throws error when args are wrong format");
        it("throws when buffer doesn't contain JSON");
        it("throws on malformatted JSON");
    });

    describe("parseAttestationObject", function() {
        it("correctly parses 'none' format", function() {
            var ret = parser.parseAttestationObject(h.lib.makeCredentialAttestationNoneResponse.response.attestationObject);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 11);
            // attStmt
            // var attStmt = ret.get("attStmt");
            // assert.isObject(attStmt);
            // assert.strictEqual(Object.keys(attStmt).length, 0);
            // assert.deepEqual(attStmt, {});
            // fmt
            var fmt = ret.get("fmt");
            assert.strictEqual(fmt, "none");
            // got the right authData CBOR
            var rawAuthData = ret.get("rawAuthData");
            assert.instanceOf(rawAuthData, ArrayBuffer);
            var expectedRawAuthData = new Uint8Array([
                0x49, 0x96, 0x0D, 0xE5, 0x88, 0x0E, 0x8C, 0x68, 0x74, 0x34, 0x17, 0x0F, 0x64, 0x76, 0x60, 0x5B,
                0x8F, 0xE4, 0xAE, 0xB9, 0xA2, 0x86, 0x32, 0xC7, 0x99, 0x5C, 0xF3, 0xBA, 0x83, 0x1D, 0x97, 0x63,
                0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x00, 0x08, 0xA2, 0xDD, 0x5E, 0xAC, 0x1A, 0x86, 0xA8,
                0xCD, 0x6E, 0xD3, 0x6C, 0xD6, 0x98, 0x94, 0x96, 0x89, 0xE5, 0xBA, 0xFC, 0x4E, 0xB0, 0x5F, 0x45,
                0x79, 0xE8, 0x7D, 0x93, 0xBA, 0x97, 0x6B, 0x2E, 0x73, 0x76, 0xB9, 0xB6, 0xDF, 0xD7, 0x16, 0xE1,
                0x64, 0x14, 0x0F, 0xF9, 0x79, 0xA6, 0xD4, 0xF3, 0x44, 0xB5, 0x3D, 0x6D, 0x26, 0xE0, 0x86, 0x7B,
                0xF4, 0x14, 0xB6, 0x91, 0x03, 0xBB, 0x65, 0xCB, 0xB2, 0xDA, 0xF7, 0xF4, 0x11, 0x28, 0x35, 0xF0,
                0x64, 0xCB, 0x1B, 0x59, 0xA8, 0xE5, 0x84, 0xA4, 0x21, 0xDA, 0x8B, 0xD8, 0x9E, 0x38, 0x7A, 0x0B,
                0x7E, 0xEA, 0xB7, 0x23, 0xEC, 0xD7, 0x9D, 0x48, 0x4C, 0x31, 0x6B, 0xFB, 0xAE, 0xC5, 0x46, 0x01,
                0xB4, 0x73, 0x67, 0x49, 0x0A, 0x83, 0x9A, 0xDA, 0x14, 0x01, 0xF3, 0x3D, 0x2D, 0x25, 0x8B, 0x97,
                0xAE, 0x41, 0x8C, 0xA5, 0x59, 0x34, 0x65, 0x29, 0xF5, 0xAA, 0x37, 0xDE, 0x63, 0x12, 0x75, 0x57,
                0xD0, 0x43, 0x46, 0xC7, 0xCD, 0xEE, 0xBD, 0x25, 0x54, 0x2F, 0x2C, 0x17, 0xFC, 0x39, 0x38, 0x99,
                0x52, 0xA2, 0x6C, 0x3A, 0xE2, 0xA6, 0xA6, 0xA5, 0x1C, 0xA5, 0x01, 0x02, 0x03, 0x26, 0x20, 0x01,
                0x21, 0x58, 0x20, 0xBB, 0x11, 0xCD, 0xDD, 0x6E, 0x9E, 0x86, 0x9D, 0x15, 0x59, 0x72, 0x9A, 0x30,
                0xD8, 0x9E, 0xD4, 0x9F, 0x36, 0x31, 0x52, 0x42, 0x15, 0x96, 0x12, 0x71, 0xAB, 0xBB, 0xE2, 0x8D,
                0x7B, 0x73, 0x1F, 0x22, 0x58, 0x20, 0xDB, 0xD6, 0x39, 0x13, 0x2E, 0x2E, 0xE5, 0x61, 0x96, 0x5B,
                0x83, 0x05, 0x30, 0xA6, 0xA0, 0x24, 0xF1, 0x09, 0x88, 0x88, 0xF3, 0x13, 0x55, 0x05, 0x15, 0x92,
                0x11, 0x84, 0xC8, 0x6A, 0xCA, 0xC3
            ]).buffer;
            assert(h.functions.arrayBufferEquals(rawAuthData, expectedRawAuthData), "authData contains right bytes");
            // parsed the authData CBOR correctly
            // var authData = ret.get("authData");
            // assert.isObject(authData);
            // assert.strictEqual(Object.keys(authData).length, 8);
            var rpIdHash = ret.get("rpIdHash");
            var expectedRpIdHash = new Uint8Array([
                0x49, 0x96, 0x0D, 0xE5, 0x88, 0x0E, 0x8C, 0x68, 0x74, 0x34, 0x17, 0x0F, 0x64, 0x76, 0x60, 0x5B,
                0x8F, 0xE4, 0xAE, 0xB9, 0xA2, 0x86, 0x32, 0xC7, 0x99, 0x5C, 0xF3, 0xBA, 0x83, 0x1D, 0x97, 0x63
            ]).buffer;
            assert(h.functions.arrayBufferEquals(rpIdHash, expectedRpIdHash), "correct rpIdHash");
            // flags
            var flags = ret.get("flags");
            assert.instanceOf(flags, Set);
            assert.strictEqual(flags.size, 2);
            assert.isTrue(flags.has("UP"));
            assert.isTrue(flags.has("AT"));
            // counter
            assert.strictEqual(ret.get("counter"), 0);
            assert.isNumber(ret.get("counter"));
            // aaguid
            var aaguid = ret.get("aaguid");
            assert.instanceOf(aaguid, ArrayBuffer);
            var expectedAaguid = new Uint8Array([
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ]).buffer;
            assert(h.functions.arrayBufferEquals(aaguid, expectedAaguid), "correct aaguid");
            // credIdLen
            assert.strictEqual(ret.get("credIdLen"), 162);
            // credId
            var credId = ret.get("credId");
            assert.instanceOf(credId, ArrayBuffer);
            var expectedCredId = new Uint8Array([
                0x00, 0x08, 0xA2, 0xDD, 0x5E, 0xAC, 0x1A, 0x86, 0xA8, 0xCD, 0x6E, 0xD3, 0x6C, 0xD6, 0x98, 0x94,
                0x96, 0x89, 0xE5, 0xBA, 0xFC, 0x4E, 0xB0, 0x5F, 0x45, 0x79, 0xE8, 0x7D, 0x93, 0xBA, 0x97, 0x6B,
                0x2E, 0x73, 0x76, 0xB9, 0xB6, 0xDF, 0xD7, 0x16, 0xE1, 0x64, 0x14, 0x0F, 0xF9, 0x79, 0xA6, 0xD4,
                0xF3, 0x44, 0xB5, 0x3D, 0x6D, 0x26, 0xE0, 0x86, 0x7B, 0xF4, 0x14, 0xB6, 0x91, 0x03, 0xBB, 0x65,
                0xCB, 0xB2, 0xDA, 0xF7, 0xF4, 0x11, 0x28, 0x35, 0xF0, 0x64, 0xCB, 0x1B, 0x59, 0xA8, 0xE5, 0x84,
                0xA4, 0x21, 0xDA, 0x8B, 0xD8, 0x9E, 0x38, 0x7A, 0x0B, 0x7E, 0xEA, 0xB7, 0x23, 0xEC, 0xD7, 0x9D,
                0x48, 0x4C, 0x31, 0x6B, 0xFB, 0xAE, 0xC5, 0x46, 0x01, 0xB4, 0x73, 0x67, 0x49, 0x0A, 0x83, 0x9A,
                0xDA, 0x14, 0x01, 0xF3, 0x3D, 0x2D, 0x25, 0x8B, 0x97, 0xAE, 0x41, 0x8C, 0xA5, 0x59, 0x34, 0x65,
                0x29, 0xF5, 0xAA, 0x37, 0xDE, 0x63, 0x12, 0x75, 0x57, 0xD0, 0x43, 0x46, 0xC7, 0xCD, 0xEE, 0xBD,
                0x25, 0x54, 0x2F, 0x2C, 0x17, 0xFC, 0x39, 0x38, 0x99, 0x52, 0xA2, 0x6C, 0x3A, 0xE2, 0xA6, 0xA6,
                0xA5, 0x1C
            ]).buffer;
            assert(h.functions.arrayBufferEquals(credId, expectedCredId), "correct credId");
            // credentialPublicKeyCose
            var credentialPublicKeyCose = ret.get("credentialPublicKeyCose");
            assert.instanceOf(credentialPublicKeyCose, ArrayBuffer);
            var expectedCredentialPublicKeyCose = new Uint8Array([
                0xA5, 0x01, 0x02, 0x03, 0x26, 0x20, 0x01, 0x21, 0x58, 0x20, 0xBB, 0x11, 0xCD, 0xDD, 0x6E, 0x9E,
                0x86, 0x9D, 0x15, 0x59, 0x72, 0x9A, 0x30, 0xD8, 0x9E, 0xD4, 0x9F, 0x36, 0x31, 0x52, 0x42, 0x15,
                0x96, 0x12, 0x71, 0xAB, 0xBB, 0xE2, 0x8D, 0x7B, 0x73, 0x1F, 0x22, 0x58, 0x20, 0xDB, 0xD6, 0x39,
                0x13, 0x2E, 0x2E, 0xE5, 0x61, 0x96, 0x5B, 0x83, 0x05, 0x30, 0xA6, 0xA0, 0x24, 0xF1, 0x09, 0x88,
                0x88, 0xF3, 0x13, 0x55, 0x05, 0x15, 0x92, 0x11, 0x84, 0xC8, 0x6A, 0xCA, 0xC3
            ]).buffer;
            assert(h.functions.arrayBufferEquals(credentialPublicKeyCose, expectedCredentialPublicKeyCose), "correct credentialPublicKeyCose");
            // credentialPublicKeyJwk
            var credentialPublicKeyJwk = ret.get("credentialPublicKeyJwk");
            assert.isObject(credentialPublicKeyJwk);
            assert.strictEqual(Object.keys(credentialPublicKeyJwk).length, 5);
            assert.strictEqual(credentialPublicKeyJwk.kty, "EC");
            assert.strictEqual(credentialPublicKeyJwk.crv, "P-256");
            assert.strictEqual(credentialPublicKeyJwk.alg, "ECDSA_w_SHA256");
            // assert.instanceOf(credentialPublicKeyJwk.x, ArrayBuffer);
            // var expectedX = new Uint8Array([
            //     0xBB, 0x11, 0xCD, 0xDD, 0x6E, 0x9E, 0x86, 0x9D, 0x15, 0x59, 0x72, 0x9A, 0x30, 0xD8, 0x9E, 0xD4,
            //     0x9F, 0x36, 0x31, 0x52, 0x42, 0x15, 0x96, 0x12, 0x71, 0xAB, 0xBB, 0xE2, 0x8D, 0x7B, 0x73, 0x1F
            // ]).buffer;
            // assert(h.functions.arrayBufferEquals(credentialPublicKeyJwk.x, expectedX), "correct 'x' in jwk");
            // assert.instanceOf(credentialPublicKeyJwk.y, ArrayBuffer);
            // var expectedY = new Uint8Array([
            //     0xDB, 0xD6, 0x39, 0x13, 0x2E, 0x2E, 0xE5, 0x61, 0x96, 0x5B, 0x83, 0x05, 0x30, 0xA6, 0xA0, 0x24,
            //     0xF1, 0x09, 0x88, 0x88, 0xF3, 0x13, 0x55, 0x05, 0x15, 0x92, 0x11, 0x84, 0xC8, 0x6A, 0xCA, 0xC3
            // ]).buffer;
            // assert(h.functions.arrayBufferEquals(credentialPublicKeyJwk.y, expectedY), "correct 'y' in jwk");
            assert.strictEqual(credentialPublicKeyJwk.x, "uxHN3W6ehp0VWXKaMNie1J82MVJCFZYScau74o17cx8=");
            assert.strictEqual(credentialPublicKeyJwk.y, "29Y5Ey4u5WGWW4MFMKagJPEJiIjzE1UFFZIRhMhqysM=");
            // credentialPublicKeyPem
            var credentialPublicKeyPem = ret.get("credentialPublicKeyPem");
            assert.isString(credentialPublicKeyPem);
            var expectedPem =
                "-----BEGIN PUBLIC KEY-----\n" +
                "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEuxHN3W6ehp0VWXKaMNie1J82MVJC\n" +
                "FZYScau74o17cx/b1jkTLi7lYZZbgwUwpqAk8QmIiPMTVQUVkhGEyGrKww==\n" +
                "-----END PUBLIC KEY-----\n";
            assert.strictEqual(credentialPublicKeyPem, expectedPem);
        });

        it("correctly parses 'u2f' format", function() {
            var ret = parser.parseAttestationObject(h.lib.makeCredentialAttestationU2fResponse.response.attestationObject);
            assert.instanceOf(ret, Map);
            assert.strictEqual(ret.size, 14);
            // fmt
            var fmt = ret.get("fmt");
            assert.strictEqual(fmt, "fido-u2f");
            // sig
            var sig = ret.get("sig");
            assert.instanceOf(sig, ArrayBuffer);
            assert.strictEqual(sig.byteLength, 72);
            var expectedSig = new Uint8Array([
                0x30, 0x46, 0x02, 0x21, 0x00, 0xEF, 0xBA, 0xF3, 0x72, 0x12, 0x26, 0x12, 0x9D, 0x99, 0x43, 0xE6,
                0x55, 0xB4, 0x2E, 0x61, 0x9B, 0x29, 0xF2, 0x59, 0x03, 0xED, 0x82, 0x5C, 0x22, 0x71, 0xD2, 0xDD,
                0x03, 0x9F, 0x6E, 0xB8, 0xA8, 0x02, 0x21, 0x00, 0xCE, 0x03, 0x09, 0xE3, 0xDF, 0x5C, 0x05, 0xCC,
                0xC1, 0xC3, 0xCD, 0xBA, 0xAF, 0x59, 0xB9, 0xE4, 0x99, 0x9D, 0xF6, 0x64, 0xF8, 0x77, 0x58, 0x84,
                0x5D, 0x84, 0xBC, 0x15, 0xB2, 0x27, 0xF0, 0xCA
            ]).buffer;
            assert(h.functions.arrayBufferEquals(sig, expectedSig), "sig contains right bytes");
            // certChain
            var certChain = ret.get("certChain");
            assert.isArray(certChain);
            assert.strictEqual(certChain.length, 0);
            // attCert
            var attCert = ret.get("attCert");
            assert.instanceOf(attCert, ArrayBuffer);
            var expectedAttCert = new Uint8Array([
                0x30, 0x82, 0x02, 0x44, 0x30, 0x82, 0x01, 0x2E, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x04, 0x55,
                0x62, 0xBE, 0xA0, 0x30, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B,
                0x30, 0x2E, 0x31, 0x2C, 0x30, 0x2A, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x23, 0x59, 0x75, 0x62,
                0x69, 0x63, 0x6F, 0x20, 0x55, 0x32, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x20,
                0x53, 0x65, 0x72, 0x69, 0x61, 0x6C, 0x20, 0x34, 0x35, 0x37, 0x32, 0x30, 0x30, 0x36, 0x33, 0x31,
                0x30, 0x20, 0x17, 0x0D, 0x31, 0x34, 0x30, 0x38, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
                0x5A, 0x18, 0x0F, 0x32, 0x30, 0x35, 0x30, 0x30, 0x39, 0x30, 0x34, 0x30, 0x30, 0x30, 0x30, 0x30,
                0x30, 0x5A, 0x30, 0x2A, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x1F, 0x59,
                0x75, 0x62, 0x69, 0x63, 0x6F, 0x20, 0x55, 0x32, 0x46, 0x20, 0x45, 0x45, 0x20, 0x53, 0x65, 0x72,
                0x69, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x33, 0x32, 0x35, 0x33, 0x34, 0x36, 0x38, 0x38, 0x30, 0x59,
                0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08, 0x2A, 0x86, 0x48,
                0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x4B, 0x33, 0x1F, 0x77, 0x3D, 0x81, 0x44,
                0xB9, 0x99, 0x5C, 0xBE, 0x45, 0x85, 0x51, 0x7E, 0x17, 0x58, 0x3A, 0xA4, 0x76, 0x23, 0x69, 0x5C,
                0xBE, 0x85, 0xAC, 0x48, 0x2C, 0x80, 0x19, 0xF2, 0xC9, 0xB9, 0x46, 0x7A, 0xE0, 0x45, 0xB0, 0xE6,
                0x6F, 0x13, 0x1B, 0x2E, 0xA3, 0x24, 0x3C, 0x91, 0xFD, 0xA6, 0x02, 0xE3, 0x18, 0xF3, 0xFC, 0x5D,
                0x8D, 0x2A, 0x7A, 0xBA, 0xE7, 0x2B, 0xD1, 0x43, 0x09, 0xA3, 0x3B, 0x30, 0x39, 0x30, 0x22, 0x06,
                0x09, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xC4, 0x0A, 0x02, 0x04, 0x15, 0x31, 0x2E, 0x33, 0x2E,
                0x36, 0x2E, 0x31, 0x2E, 0x34, 0x2E, 0x31, 0x2E, 0x34, 0x31, 0x34, 0x38, 0x32, 0x2E, 0x31, 0x2E,
                0x35, 0x30, 0x13, 0x06, 0x0B, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xE5, 0x1C, 0x02, 0x01, 0x01,
                0x04, 0x04, 0x03, 0x02, 0x05, 0x20, 0x30, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D,
                0x01, 0x01, 0x0B, 0x03, 0x82, 0x01, 0x01, 0x00, 0xAC, 0x16, 0xD9, 0xB3, 0x6E, 0xB6, 0xB3, 0xA9,
                0xB7, 0x6D, 0x75, 0x94, 0xB3, 0x4F, 0x59, 0xF4, 0xF7, 0x3E, 0xDB, 0xC9, 0xFD, 0xEB, 0x29, 0x35,
                0xEB, 0x6B, 0x45, 0x1C, 0xAB, 0xF4, 0x1D, 0x25, 0xD3, 0xE7, 0x16, 0x14, 0xD7, 0x47, 0x26, 0x04,
                0xCA, 0x72, 0xA5, 0x78, 0xE3, 0x23, 0xED, 0xB7, 0x60, 0x04, 0x68, 0x5F, 0x05, 0xE7, 0xD1, 0xB9,
                0xBE, 0x05, 0xDB, 0x6E, 0x94, 0x40, 0xFA, 0xC5, 0xCF, 0xC9, 0x32, 0xA6, 0xCA, 0xFA, 0xE8, 0x52,
                0x99, 0x77, 0x2E, 0xDB, 0x02, 0x78, 0x20, 0x20, 0x3C, 0xD4, 0x14, 0x1D, 0x3E, 0xEB, 0x6F, 0x6A,
                0x2C, 0xE9, 0x9E, 0x39, 0x57, 0x80, 0x32, 0x63, 0xAB, 0xAB, 0x8D, 0x6E, 0xC4, 0x80, 0xA7, 0xDF,
                0x08, 0x4A, 0xD2, 0xCB, 0xA7, 0xB7, 0xD6, 0xD7, 0x7C, 0x94, 0xC3, 0xEB, 0xC0, 0xB1, 0x66, 0xF9,
                0x60, 0x57, 0xCA, 0xF5, 0xFE, 0x3A, 0x63, 0x1E, 0xA2, 0x6A, 0x43, 0x37, 0x62, 0xA3, 0x6F, 0xBE,
                0xCF, 0x4C, 0xF4, 0x45, 0x09, 0x62, 0x5F, 0xD5, 0xAF, 0x10, 0x49, 0xAA, 0x7C, 0x8B, 0xC7, 0x68,
                0x9A, 0x66, 0x59, 0xE9, 0xAF, 0x5D, 0xE8, 0xF0, 0xD7, 0x2C, 0x28, 0x82, 0x51, 0x74, 0xC5, 0x0E,
                0x06, 0xAB, 0x7F, 0x6A, 0x07, 0x90, 0x83, 0x7B, 0x6D, 0xB3, 0x2A, 0xBF, 0xDC, 0xBC, 0xA8, 0x35,
                0xCB, 0xBB, 0x09, 0x0E, 0xF1, 0xF0, 0xD9, 0x9E, 0x08, 0x69, 0xBF, 0xE9, 0xE5, 0x67, 0x64, 0xC4,
                0x23, 0x0E, 0x6C, 0x05, 0x77, 0x29, 0xB0, 0x10, 0xDE, 0x0E, 0xC5, 0xF9, 0xCC, 0xE4, 0xC9, 0x1C,
                0x28, 0x26, 0x21, 0x8E, 0xA8, 0x08, 0x1A, 0xBB, 0x96, 0x91, 0x51, 0xEC, 0x16, 0x72, 0x5A, 0xF2,
                0xA8, 0xD9, 0x5E, 0x77, 0x95, 0xBC, 0xAA, 0x22, 0x7A, 0x9B, 0x94, 0x43, 0x20, 0xC4, 0x27, 0x61,
                0x9C, 0xAA, 0xF8, 0x54, 0xD9, 0x82, 0x98, 0xD7
            ]).buffer;
            assert(h.functions.arrayBufferEquals(attCert, expectedAttCert), "attCert contains right bytes");
            // got the right authData CBOR
            var rawAuthData = ret.get("rawAuthData");
            assert.instanceOf(rawAuthData, ArrayBuffer);
            var expectedRawAuthData = new Uint8Array([
                0x49, 0x96, 0x0D, 0xE5, 0x88, 0x0E, 0x8C, 0x68, 0x74, 0x34, 0x17, 0x0F, 0x64, 0x76, 0x60, 0x5B,
                0x8F, 0xE4, 0xAE, 0xB9, 0xA2, 0x86, 0x32, 0xC7, 0x99, 0x5C, 0xF3, 0xBA, 0x83, 0x1D, 0x97, 0x63,
                0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x06, 0x8F, 0x95, 0x8C, 0x73, 0xA4, 0x25, 0x9C, 0xBC,
                0x0E, 0x39, 0xC2, 0x26, 0x72, 0x1C, 0xD0, 0xEC, 0x6D, 0xF5, 0x00, 0x33, 0xE6, 0xEA, 0x4C, 0x75,
                0x22, 0x71, 0x35, 0xB7, 0x7E, 0x1B, 0x20, 0x28, 0xE8, 0xC3, 0x48, 0xBC, 0xF0, 0x5B, 0xF5, 0x8B,
                0x14, 0x94, 0x4D, 0x19, 0x25, 0xA6, 0x96, 0x5E, 0xD5, 0x87, 0xE4, 0x54, 0x32, 0x3D, 0x2E, 0x9B,
                0x4F, 0xF7, 0xBA, 0xF7, 0xC2, 0x22, 0xAD, 0xA5, 0x01, 0x02, 0x03, 0x26, 0x20, 0x01, 0x21, 0x58,
                0x20, 0x35, 0x73, 0xD0, 0x08, 0x78, 0x7E, 0x6C, 0x37, 0xAC, 0x75, 0x43, 0xED, 0xAA, 0x47, 0xBB,
                0xF6, 0xE7, 0x9B, 0x64, 0x78, 0x66, 0xD6, 0xB3, 0x41, 0x02, 0x08, 0x3C, 0x37, 0xE6, 0x42, 0x46,
                0x04, 0x22, 0x58, 0x20, 0x18, 0xD3, 0x53, 0x1A, 0xEE, 0x69, 0xD8, 0xC5, 0x14, 0xC9, 0xD6, 0x95,
                0x1E, 0x6B, 0x3C, 0x9A, 0xF6, 0xDE, 0xC0, 0x49, 0x4F, 0xDA, 0x9E, 0xC5, 0x8F, 0x4F, 0x09, 0xCF,
                0x68, 0xF2, 0x19, 0x93
            ]).buffer;
            assert(h.functions.arrayBufferEquals(rawAuthData, expectedRawAuthData), "authData contains right bytes");
            // parsed the authData CBOR correctly
            // var authData = ret.get("authData");
            // assert.isObject(authData);
            // assert.strictEqual(Object.keys(authData).length, 8);
            var rpIdHash = ret.get("rpIdHash");
            var expectedRpIdHash = new Uint8Array([
                0x49, 0x96, 0x0D, 0xE5, 0x88, 0x0E, 0x8C, 0x68, 0x74, 0x34, 0x17, 0x0F, 0x64, 0x76, 0x60, 0x5B,
                0x8F, 0xE4, 0xAE, 0xB9, 0xA2, 0x86, 0x32, 0xC7, 0x99, 0x5C, 0xF3, 0xBA, 0x83, 0x1D, 0x97, 0x63
            ]).buffer;
            assert(h.functions.arrayBufferEquals(rpIdHash, expectedRpIdHash), "correct rpIdHash");
            // flags
            var flags = ret.get("flags");
            assert.instanceOf(flags, Set);
            assert.strictEqual(flags.size, 2);
            assert.isTrue(flags.has("UP"));
            assert.isTrue(flags.has("AT"));
            // counter
            assert.strictEqual(ret.get("counter"), 0);
            assert.isNumber(ret.get("counter"));
            // aaguid
            var aaguid = ret.get("aaguid");
            assert.instanceOf(aaguid, ArrayBuffer);
            var expectedAaguid = new Uint8Array([
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ]).buffer;
            assert(h.functions.arrayBufferEquals(aaguid, expectedAaguid), "correct aaguid");
            // credIdLen
            assert.strictEqual(ret.get("credIdLen"), 64);
            // credId
            var credId = ret.get("credId");
            assert.instanceOf(credId, ArrayBuffer);
            var expectedCredId = new Uint8Array([
                0x06, 0x8F, 0x95, 0x8C, 0x73, 0xA4, 0x25, 0x9C, 0xBC, 0x0E, 0x39, 0xC2, 0x26, 0x72, 0x1C, 0xD0,
                0xEC, 0x6D, 0xF5, 0x00, 0x33, 0xE6, 0xEA, 0x4C, 0x75, 0x22, 0x71, 0x35, 0xB7, 0x7E, 0x1B, 0x20,
                0x28, 0xE8, 0xC3, 0x48, 0xBC, 0xF0, 0x5B, 0xF5, 0x8B, 0x14, 0x94, 0x4D, 0x19, 0x25, 0xA6, 0x96,
                0x5E, 0xD5, 0x87, 0xE4, 0x54, 0x32, 0x3D, 0x2E, 0x9B, 0x4F, 0xF7, 0xBA, 0xF7, 0xC2, 0x22, 0xAD
            ]).buffer;
            assert(h.functions.arrayBufferEquals(credId, expectedCredId), "correct credId");
            // credentialPublicKeyCose
            var credentialPublicKeyCose = ret.get("credentialPublicKeyCose");
            assert.instanceOf(credentialPublicKeyCose, ArrayBuffer);
            var expectedCredentialPublicKeyCose = new Uint8Array([
                0xA5, 0x01, 0x02, 0x03, 0x26, 0x20, 0x01, 0x21, 0x58, 0x20, 0x35, 0x73, 0xD0, 0x08, 0x78, 0x7E,
                0x6C, 0x37, 0xAC, 0x75, 0x43, 0xED, 0xAA, 0x47, 0xBB, 0xF6, 0xE7, 0x9B, 0x64, 0x78, 0x66, 0xD6,
                0xB3, 0x41, 0x02, 0x08, 0x3C, 0x37, 0xE6, 0x42, 0x46, 0x04, 0x22, 0x58, 0x20, 0x18, 0xD3, 0x53,
                0x1A, 0xEE, 0x69, 0xD8, 0xC5, 0x14, 0xC9, 0xD6, 0x95, 0x1E, 0x6B, 0x3C, 0x9A, 0xF6, 0xDE, 0xC0,
                0x49, 0x4F, 0xDA, 0x9E, 0xC5, 0x8F, 0x4F, 0x09, 0xCF, 0x68, 0xF2, 0x19, 0x93
            ]).buffer;
            assert(h.functions.arrayBufferEquals(credentialPublicKeyCose, expectedCredentialPublicKeyCose), "correct credentialPublicKeyCose");
            // credentialPublicKeyJwk
            var credentialPublicKeyJwk = ret.get("credentialPublicKeyJwk");
            assert.isObject(credentialPublicKeyJwk);
            assert.strictEqual(Object.keys(credentialPublicKeyJwk).length, 5);
            assert.strictEqual(credentialPublicKeyJwk.kty, "EC");
            assert.strictEqual(credentialPublicKeyJwk.crv, "P-256");
            assert.strictEqual(credentialPublicKeyJwk.alg, "ECDSA_w_SHA256");
            assert.strictEqual(credentialPublicKeyJwk.x, "NXPQCHh+bDesdUPtqke79uebZHhm1rNBAgg8N+ZCRgQ=");
            assert.strictEqual(credentialPublicKeyJwk.y, "GNNTGu5p2MUUydaVHms8mvbewElP2p7Fj08Jz2jyGZM=");
            // credentialPublicKeyPem
            var credentialPublicKeyPem = ret.get("credentialPublicKeyPem");
            assert.isString(credentialPublicKeyPem);
            var expectedPem =
                "-----BEGIN PUBLIC KEY-----\n" +
                "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENXPQCHh+bDesdUPtqke79uebZHhm\n" +
                "1rNBAgg8N+ZCRgQY01Ma7mnYxRTJ1pUeazya9t7ASU/ansWPTwnPaPIZkw==\n" +
                "-----END PUBLIC KEY-----\n";
            assert.strictEqual(credentialPublicKeyPem, expectedPem);
        });

        it("throws if input isn't Buffer");
        it("throws on random data");
        it("throws on malformatted CBOR");
    });

    describe("parseAttestationStatement", function() {});

    describe("parseAssertionData", function() {
        it("parses assertion correctly", function() {
            var ret = parser.parseAssertionData(h.lib.assertionResponse.response.authenticatorData);
            console.log("authenticatorData", ret);
            assert.instanceOf(ret, Map);
        });
    });
});